#version 330 core
out vec3 FragColor;

// Interpolated values from the vertex shaders
in vec2 UV;
in vec3 Position_worldspace;
in vec3 Normal_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec3 LightDirection_cameraspace;
in vec4 col;

// constants for whole mesh
uniform sampler2D texture_diffuse1;
uniform sampler2D texture_emissive1;
uniform sampler2D texture_specular1; // this is being used as a mask texture so we can blend with some interest!

uniform vec4 light;	// light position (xyz) and light power (w)
uniform vec3 lightColour;
uniform float ambientlevel;
uniform float transitionpower;	// see app
uniform float blendamount;		// see app
uniform float masktexturescale;	// see app
uniform bool showVertexColour;	// see app

void main()
{    
	// Lighting properties
	float LightPower = light.w;

	// masktexturescale fed in from program so we can see the effect of scaling it
	vec2 scaleduv = UV * masktexturescale;

	// col = vertex colour.. RGBA as floats.. use the R channel to do some interesting blending here

	// Material properties
	// try doing a mix(tex1,tex2,blendamount) here?
	vec3 MaterialDiffuseColor = texture( texture_diffuse1, UV ).rgb;
	// don't forget to try scaling the mask texture!

	// show vertex colour toggles between textured view and greyscale view of R channel in vertex colours
	if(showVertexColour == true)
	{
		MaterialDiffuseColor = vec3(col.r,col.r,col.r);
	}
		
	vec3 MaterialAmbientColor = vec3(ambientlevel,ambientlevel,ambientlevel) * MaterialDiffuseColor;
	// TODO: take this from a texture? beware though, in this shader specular texture is being abused for something else
	vec3 MaterialSpecularColor = vec3(0.5,0.5,0.5);

	// Distance to the light
	float distance = length( light.xyz - Position_worldspace );

	// Normal of the computed fragment, in camera space
	vec3 n = normalize( Normal_cameraspace );
	// Direction of the light (from the fragment to the light)
	vec3 l = normalize( LightDirection_cameraspace );
	// Cosine of the angle between the normal and the light direction, 
	// clamped above 0
	//  - light is at the vertical of the triangle -> 1
	//  - light is perpendicular to the triangle -> 0
	//  - light is behind the triangle -> 0
	float cosTheta = clamp( dot( n,l ), 0,1 );
	
	FragColor = 
		// Ambient : simulates indirect lighting
		MaterialAmbientColor +
		// Diffuse : "color" of the object
		MaterialDiffuseColor * lightColour * LightPower * cosTheta / (distance*distance);
		// TODO: Add specular term back in here
		

}